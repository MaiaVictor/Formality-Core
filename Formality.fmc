// Equality
// ========

Equal: (A: Type) -> A -> A -> Type
  (A) (a) (b)
  equal_value<P: (b: A) -> Equal(A)(a)(b) -> Type> ->
  (equal: P(a)(equal<A><a>)) ->
  P(b)(equal_value)

equal: <A: Type> -> <a: A> -> Equal(A)(a)(a)
  <A> <a>
  <P> (equal)
  equal

// Bool
// ====

Bool: Type //prim//
  bool_value<P: Bool -> Type> ->
  P(true) ->
  P(false) ->
  P(bool_value)

true: Bool
  <> (t) (f) t

false: Bool
  <> (t) (f) f

_bool : (b: Bool) -> <P: Bool -> Type> -> P(true) -> P(false) -> P(b)
  (b) <P> (t) (f) b<P>(t)(f)

bool_not: Bool -> Bool //prim//
  (a)
  a<() Bool>
  | false;
  | true;

bool_notf: Bool -> Bool
  (a)
  <P> (t) (f)
  a<(self) P(bool_notf(self))>
  | f;
  | t;

bool_or: Bool -> Bool -> Bool //prim//
  (a) (b)
  a<() Bool>
  | b<() Bool>
    | true;
    | true;;
  | b<() Bool>
    | true;
    | false;;

bool_and: Bool -> Bool -> Bool //prim//
  (a) (b)
  a<() Bool>
  | b<() Bool>
    | true;
    | false;;
  | b<() Bool>
    | false;
    | false;;

// Cmp

Cmp : Type
  cmp_value<P: Cmp -> Type> ->
  P(ltn) ->
  P(eql) ->
  P(gtn) ->
  P(cmp_value)

ltn: Cmp
  <> (ltn) (eql) (gtn) ltn

eql: Cmp
  <> (ltn) (eql) (gtn) eql

gtn: Cmp
  <> (ltn) (eql) (gtn) gtn

// Bit
// ===

Bit : Type
  bit_value<P: Bit -> Type> ->
  P(o) ->
  P(i) ->
  P(bit_value)

o: Bit
  <> (o) (i) o

i: Bit
  <> (o) (i) i

// Nat
// ===

Nat: Type //prim//
  nat_value<P: Nat -> Type> ->
  (zero: P(zero)) ->
  (succ: (pred: Nat) -> P(succ(pred))) ->
  P(nat_value)

zero: Nat
  <> (z) (s) z

succ: Nat -> Nat
  (n)
  <> (z) (s) s(n)

pred: Nat -> Nat
  (n)
  n<() Nat>
  | zero;
  | (n.pred) n.pred;

fold_nat : (n: Nat) -> <P: Nat -> Type> -> P(zero) -> ((n:Nat) -> P(n) -> P(succ(n))) -> P(n)
  (n) <P> (z) (s)
  n<P>(z)((pred) s(pred)(fold_nat(pred)<P>(z)(s)))

double: Nat -> Nat
  (n)
  n<() Nat>
  | zero;
  | (n.pred) succ(succ(double(n.pred)));

nat_add: Nat -> Nat -> Nat //prim//
  (n) (m)
  n<() Nat>
  | m;
  | (n.pred) nat_add(n.pred)(succ(m));

nat_sub: Nat -> Nat -> Nat //prim//
  (n) (m)
  m<() Nat>
  | n;
  | (m.pred) nat_sub(pred(n))(m.pred);

nat_mul: Nat -> Nat -> Nat //prim//
  (n) (m)
  n<() Nat>
  | n0;
  | (n.pred) nat_add(m)(nat_mul(n.pred)(m));

nat_cmp: Nat -> Nat -> Cmp
  (a) (b)
  a<() Cmp>
  | b<() Cmp>
    | eql;
    | (b.pred) ltn;;
  | (a.pred)
    b<() Cmp>
    | gtn;
    | (b.pred) nat_cmp(a.pred)(b.pred);;

nat_ltn: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(true)(false)(false)

nat_lte: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(true)(true)(false)

nat_eql: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(false)(true)(false)

nat_gte: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(false)(true)(true)

nat_gtn: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(false)(false)(true)

nat_sum_go: Nat -> Nat -> Nat //loop//
  (n) (r)
  n<() Nat>
  | r;
  | (n.pred) nat_sum_go(n.pred)(nat_add(n)(r));

nat_sum: Nat -> Nat
  (n) nat_sum_go(n)(zero)

n0: Nat
  zero

n1: Nat
  succ(n0)

n2: Nat
  succ(n1)

n3: Nat
  succ(n2)

n4: Nat
  succ(n3)

n5: Nat
  succ(n4)

n6: Nat
  succ(n5)

n7: Nat
  succ(n6)

n8: Nat
  succ(n7)

n9: Nat
  succ(n8)

n9: Nat
  succ(n8)

n10: Nat
  succ(n9)

n11: Nat
  succ(n10)

n12: Nat
  succ(n11)

n13: Nat
  succ(n12)

n14: Nat
  succ(n13)

n15: Nat
  succ(n14)

n16: Nat
  succ(n15)

n17: Nat
  succ(n16)

n18: Nat
  succ(n17)

n19: Nat
  succ(n18)

n20: Nat
  succ(n19)

n21: Nat
  succ(n20)

n22: Nat
  succ(n21)

n23: Nat
  succ(n22)

n24: Nat
  succ(n23)

n25: Nat
  succ(n24)

n26: Nat
  succ(n25)

n27: Nat
  succ(n26)

n28: Nat
  succ(n27)

n29: Nat
  succ(n28)

n30: Nat
  succ(n29)

n31: Nat
  succ(n30)

n32: Nat
  succ(n31)

// Pair
// ====

Pair: Type -> Type -> Type
  (A) (B)
  pair_value<P: Pair(A)(B) -> Type> ->
  (pair: (a: A) -> (b: B) -> P(pair<A><B>(a)(b))) ->
  P(pair_value)

pair: <A: Type> -> <B: Type> -> A -> B -> Pair(A)(B)
  <> <> (a) (b)
  <> (pair)
  pair(a)(b)

fst: <A: Type> -> <B: Type> -> Pair(A)(B) -> A
  <A> <B> (pair)
  pair<() A>((a) (b) a)

snd: <A: Type> -> <B: Type> -> Pair(A)(B) -> B
  <A> <B> (pair)
  pair<() B>((a) (b) b)

// Maybe
// =====

Maybe: Type -> Type
  (A)
  maybe_value<P: Maybe(A) -> Type> ->
  (none: P(none<A>)) ->
  (some: (value: A) -> P(some<A>(value))) ->
  P(maybe_value)

none: <A: Type> -> Maybe(A)
  <>
  <> (none) () none

some: <A: Type> -> A -> Maybe(A)
  <> (value)
  <> () (some) some(value)

// List
// ====

List: (A: Type) -> Type
  (A)
  list_value<P: (x: List(A)) -> Type> ->
  (nil: P(nil<A>)) ->
  (cons: (head: A) -> (tail: List(A)) -> P(cons<A>(head)(tail))) ->
  P(list_value)

nil: <A: Type> -> List(A)
  <A>
  <> (nil) () nil

cons: <A: Type> -> (:A) -> (:List(A)) -> List(A)
  <A> (head) (tail)
  <> () (cons) cons(head)(tail)

find_aux: <A: Type> -> List(A) -> (A -> Nat -> Bool) -> Nat -> Maybe(Pair(A)(Nat))
  <A> (list) (cond) (indx)
  list<() Maybe(Pair(A)(Nat))>
  | none<Pair(A)(Nat)>;
  | (head) (tail)
    cond(head)(indx)<() Maybe(Pair(A)(Nat))>
    | some<Pair(A)(Nat)>(pair<A><Nat>(head)(indx));
    | find_aux<A>(tail)(cond)(succ(indx));;

find: <A: Type> -> List(A) -> (A -> Nat -> Bool) -> Maybe(Pair(A)(Nat))
  <A> (list) (cond)
  find_aux<A>(list)(cond)(zero)

take: <A: Type> -> Nat -> List(A) -> List(A)
  <A> (n) (list)
  list<() List(A)>
  | nil<A>;
  | (head) (tail)
    n<() List(A)>
    | nil<A>;
    | (pred) cons<A>(head)(take<A>(pred)(tail));;

drop: <A: Type> -> Nat -> List(A) -> List(A)
  <A> (n) (list)
  n<() List(A)>
  | list;
  | (pred)
    list<() List(A)>
    | nil<A>;
    | (head) (tail) drop<A>(pred)(tail);;

is_empty: <A: Type> -> List(A) -> Bool
  <A> (list)
  list<() Bool>
  | true;
  | (head) (tail) false;

zip_with: <A: Type> -> <B: Type> -> <C: Type> -> (A -> B -> C) -> List(A) -> List(B) -> List(C)
  <A> <B> <C> (fn) (as) (bs)
  as<() List(C)>
  | nil<C>;
  | (a.head) (a.tail)
    bs<() List(C)>
    | nil<C>;
    | (b.head) (b.tail)
      let head = fn(a.head)(b.head)
      let tail = zip_with<A><B><C>(fn)(a.tail)(b.tail)
      cons<C>(head)(tail);;

map: <A: Type> -> <B: Type> -> (A -> B) -> List(A) -> List(B)
  <A> <B> (fn) (list)
  list<() List(B)>
  | nil<B>;
  | (list.head) (list.tail)
    cons<B>(fn(list.head))(map<A><B>(fn)(list.tail));

fold: <A: Type> -> <B: Type> -> B -> (A -> B -> B) -> List(A) -> B
  <A> <B> (nil) (cons) (list)
  list<() B>
  | nil;
  | (list.head) (list.tail)
    cons(list.head)(fold<A><B>(nil)(cons)(list.tail));

all_satisfy: <A: Type> -> (A -> Bool) -> List(A) -> Bool
  <A> (cond) (list)
  list<() Bool>
  | true;
  | (head) (tail)
    cond(head)<() Bool>
    | all_satisfy<A>(cond)(tail);
    | false;;

any_satisfy: <A: Type> -> (A -> Bool) -> List(A) -> Bool
  <A> (cond) (list)
  list<() Bool>
  | false;
  | (head) (tail)
    cond(head)<() Bool>
    | true;
    | any_satisfy<A>(cond)(tail);;

all_true: List(Bool) -> Bool
  (list) all_satisfy<Bool>((x) x)(list)

any_true: List(Bool) -> Bool
  (list) any_satisfy<Bool>((x) x)(list)

list_len: <A: Type> -> List(A) -> Nat
  <A> (list)
  list<() Nat>
  | zero;
  | (head) (tail)
    succ(list_len<A>(tail));

concat: <A: Type> -> List(A) -> List(A) -> List(A)
  <A> (as) (bs)
  as<() List(A)>
  | bs;
  | (head) (tail)
    cons<A>(head)(concat<A>(tail)(bs));

flatten : <A: Type> -> List(List(A)) -> List(A)
  <A> (as)
  as<() List(A)>
  | nil<A>;
  | (head) (tail)
    concat<A>(head)(flatten<A>(tail));

single : <A : Type> -> (x : A) -> List(A)
  <A> (x) cons<A>(x)(nil<A>)

Concat: (A : Type) -> Type
  (A) List(A) -> List(A)

list_to_concat: <A: Type> -> (xs: List(A)) -> Concat(A)
  <A> (xs)
  xs<() Concat(A)>
  | (ys) ys;
  | (head) (tail) (ys) cons<A>(head)(list_to_concat<A>(tail)(ys));

concat_to_list: <A: Type> -> (xs: Concat(A)) -> List(A)
  <A> (xs) xs(nil<A>)

// Bits
// ====

Bits: Type
  bits_value<P: Bits -> Type> ->
  (be: P(be)) ->
  (b0: (pred: Bits) -> P(b0(pred))) ->
  (b1: (pred: Bits) -> P(b1(pred))) ->
  P(bits_value)

be: Bits
  <P> (be) (b0) (b1) be

b0: (bs: Bits) -> Bits
  (bs) <P> (be) (b0) (b1) b0(bs)

b1: (bs: Bits) -> Bits
  (bs) <P> (be) (b0) (b1) b1(bs)

bits_concat: Bits -> Bits -> Bits
  (a) (b)
  a<() Bits>
  | b;
  | (a.pred) b0(bits_concat(a.pred)(b));
  | (a.pred) b1(bits_concat(a.pred)(b));

// Word
// ====

Word: Nat -> Type
  (size)
  word_value<P: (size: Nat) -> Word(size) -> Type> ->
  (we: P(zero)(we)) ->
  (w0: <size: Nat> -> (pred: Word(size)) -> P(succ(size))(w0<size>(pred))) ->
  (w1: <size: Nat> -> (pred: Word(size)) -> P(succ(size))(w1<size>(pred))) ->
  P(size)(word_value)

we: Word(zero)
  <P> (we) (w0) (w1)
  we

w0: <size: Nat> -> Word(size) -> Word(succ(size))
  <size> (wo) <P> (we) (w0) (w1)
  w0<size>(wo)

w1: <size: Nat> -> Word(size) -> Word(succ(size))
  <size> (wo) <P> (we) (w0) (w1)
  w1<size>(wo)

word_inc: <size: Nat> -> Word(size) -> Word(size)
  <size> (word)
  word<(size) () Word(size)>
  | we;
  | <size> (pred) w1<size>(pred);
  | <size> (pred) w0<size>(word_inc<size>(pred));

word_add_aux: <size: Nat> -> Word(size) -> Word(size) -> Bool -> Word(size)
  <size> (a) (b) (c)
  ( a<(a.size) () Word(a.size) -> Word(a.size)>
  | (b) we;
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Word(b.size)>
    | (a.pred)
      we;
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));  // a=0 b=0 c=0
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));; // a=0 b=0 c=1
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=0 b=1 c=0
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));  // a=0 b=1 c=1
    ;)(a.pred);
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Word(b.size)>
    | (a.pred) we;
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=1 b=0 c=0
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));; // a=1 b=0 c=1
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=1 b=1 c=0
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=1 b=1 c=1
    ;)(a.pred)
  ;)(b)

word_add: <size: Nat> -> Word(size) -> Word(size) -> Word(size)
  <size> (a) (b) word_add_aux<size>(a)(b)(false)

word_cmp_aux: <size: Nat> -> Word(size) -> Word(size) -> Cmp -> Cmp
  <size> (a) (b) (c)
  ( a<(a.size) () Word(a.size) -> Cmp>
  | (b) c;
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Cmp>
    | (a.pred) c;
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(c);
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(ltn)
    ; )(a.pred);
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Cmp>
    | (a.pred) c;
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(gtn);
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(c)
    ; )(a.pred)
  ; )(b)

word_cmp: <size: Nat> -> Word(size) -> Word(size) -> Cmp
  <size> (a) (b)
  word_cmp_aux<size>(a)(b)(eql)

// a > b
word_ltn: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(true)(false)(false)

// a <= b
word_lte: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(true)(true)(false)

// a == b
word_eql: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(false)(true)(false)

// a >= b
word_gte: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(false)(true)(true)

// a > b
word_gtn: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(false)(false)(true)

word_to_bits: <size: Nat> -> Word(size) -> Bits
  <size> (a)
  a<() () Bits>
  | be;
  | <size> (pred) b0(word_to_bits<size>(pred));
  | <size> (pred) b1(word_to_bits<size>(pred));

// Uint32
// ======

U32: Type //prim//
  u32_value<P: U32 -> Type> ->
  (u32: (a: Word(n32)) -> P(u32(a))) ->
  P(u32_value)

u32: Word(n32) -> U32
  (a)
  <> (u32) u32(a)

u32_0: U32
  u32(
    w0<n31>(w0<n30>(w0<n29>(w0<n28>(w0<n27>(w0<n26>(w0<n25>(w0<n24>(
    w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
    w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
    w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
    we)))))))))))))))))))))))))))))))))

u32_inc: U32 -> U32
  (a)
  a<() U32> | (a_val)
  u32(word_inc<n32>(a_val));

u32_add: U32 -> U32 -> U32
  (a) (b)
  a<() U32> | (a_val)
  b<() U32> | (b_val)
  u32(word_add<n32>(a_val)(b_val));;

// a < b
u32_ltn: U32 -> U32 -> Bool
  (a) (b)
  a<() Bool> | (a_val)
  b<() Bool> | (b_val)
  word_ltn<n32>(a_val)(b_val);;

// a <= b
u32_lte: U32 -> U32 -> Bool
  (a) (b)
  a<() Bool> | (a_val)
  b<() Bool> | (b_val)
  word_lte<n32>(a_val)(b_val);;

// a == b
u32_eql: U32 -> U32 -> Bool
  (a) (b)
  a<() Bool> | (a_val)
  b<() Bool> | (b_val)
  word_eql<n32>(a_val)(b_val);;

// a >= b
u32_gte: U32 -> U32 -> Bool
  (a) (b)
  a<() Bool> | (a_val)
  b<() Bool> | (b_val)
  word_gte<n32>(a_val)(b_val);;

// a > b
u32_gtn: U32 -> U32 -> Bool
  (a) (b)
  a<() Bool> | (a_val)
  b<() Bool> | (b_val)
  word_gtn<n32>(a_val)(b_val);;

u32_to_bits: U32 -> Bits
  (a)
  a<() Bits> | (a_val)
  word_to_bits<n32>(a_val);

// Char
// ====

Char: Type
  U32

ascii: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Char
  (a) (b) (c) (d) (e) (f) (g) (h)
  let wA = a<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wB = b<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wC = c<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wD = d<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wE = e<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wF = f<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wG = g<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  let wH = h<() <size: Nat> -> Word(size) -> Word(succ(size))>(w0)(w1)
  u32(
    wH<n31>(wG<n30>(wF<n29>(wE<n28>(wD<n27>(wC<n26>(wB<n25>(wA<n24>(
    w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
    w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
    w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
    we)))))))))))))))))))))))))))))))))

// String
// ======

String: Type //prim//
  string_value<P: String -> Type> ->
  (string_nil: P(string_nil)) ->
  (string_cons: (head: Char) -> (tail: String) -> P(string_cons(head)(tail))) ->
  P(string_value)

string_nil: String
  <> (string_nil) () string_nil

string_cons: Char -> String -> String
  (head) (tail)
  <> () (string_cons) string_cons(head)(tail)

string_take: Nat -> String -> String
  (n) (list)
  list<() String>
  | string_nil;
  | (head) (tail)
    n<() String>
    | string_nil;
    | (pred) string_cons(head)(string_take(pred)(tail));;

string_drop: Nat -> String -> String
  (n) (list)
  n<() String>
  | list;
  | (pred)
    list<() String>
    | string_nil;
    | (head) (tail) string_drop(pred)(tail);;

string_eql: String -> String -> Bool
  (a) (b)
  a<() Bool>
  | b<() Bool>
    | true;
    | (b.head) (b.tail) false;;
  | (a.head) (a.tail)
    b<() Bool>
    | false;
    | (b.head) (b.tail)
      bool_and(u32_eql(a.head)(b.head))(string_eql(a.tail)(b.tail));;

string_to_bits: String -> Bits
  (str)
  str<() Bits>
  | be;
  | (str.head) (str.tail)
    bits_concat(u32_to_bits(str.head))(string_to_bits(str.tail));

string_is_empty: String -> Bool
  (str)
  str<() Bool>
  | true;
  | (head) (tail) false;

string_concat: String -> String -> String
  (as) (bs)
  as<() String>
  | bs;
  | (head) (tail)
    string_cons(head)(string_concat(tail)(bs));

string_flatten: List(String) -> String
  (as)
  as<() String>
  | string_nil;
  | (head) (tail)
    string_concat(head)(string_flatten(tail));

nat_to_string: Nat -> String
  (n)
  n<() String>
  | string_cons(_z)(string_nil);
  | (n.pred) string_cons(_s)(nat_to_string(n.pred));

// Map
// ===

Map: (A: Type) -> Type
  (A)
  map_value<P: Map(A) -> Type> ->
  (empty:
    P(empty<A>)) ->
  (multi:
    (val: Maybe(A)) ->
    (lft: Map(A)) ->
    (rgt: Map(A)) ->
    P(multi<A>(val)(lft)(rgt))) ->
  P(map_value)

empty: <A: Type> -> Map(A)
  <>
  <> (empty) ()
  empty

multi: <A: Type> -> Maybe(A) -> Map(A) -> Map(A) -> Map(A)
  <> (val) (lft) (rgt)
  <> () (multi)
  multi(val)(lft)(rgt)

insert: <A: Type> -> Bits -> A -> Map(A) -> Map(A)
  <A> (bits) (val) (map)
  bits<() Map(A)>
  | map<() Map(A)>
    | multi<A>(some<A>(val))(empty<A>)(empty<A>);
    | (map.val) (map.lft) (map.rgt)
      multi<A>(some<A>(val))(map.lft)(map.rgt);;
  | (bits.pred)
    map<() Map(A)>
    | multi<A>(none<A>)(insert<A>(bits.pred)(val)(empty<A>))(empty<A>);
    | (map.val) (map.lft) (map.rgt)
      multi<A>(map.val)(insert<A>(bits.pred)(val)(map.lft))(map.rgt);;
  | (bits.pred)
    map<() Map(A)>
    | multi<A>(none<A>)(empty<A>)(insert<A>(bits.pred)(val)(empty<A>));
    | (map.val) (map.lft) (map.rgt)
      multi<A>(map.val)(map.lft)(insert<A>(bits.pred)(val)(map.rgt));;

lookup: <A: Type> -> Bits -> Map(A) -> Maybe(A)
  <A> (bits) (map)
  bits<() Maybe(A)>
  | map<() Maybe(A)>
    | none<A>;
    | (map.val) (map.lft) (map.rgt)
      map.val;;
  | (bits.pred)
    map<() Maybe(A)>
    | none<A>;
    | (map.val) (map.lft) (map.rgt)
      lookup<A>(bits.pred)(map.lft);;
  | (bits.pred)
    map<() Maybe(A)>
    | none<A>;
    | (map.val) (map.lft) (map.rgt)
      lookup<A>(bits.pred)(map.rgt);;

map_maybe: <A: Type> -> <B: Type> -> (A -> B) -> Maybe(A) -> Maybe(B)
  <A> <B> (fn) (maybe)
  maybe<() Maybe(B)>
  | none<B>;
  | (value) some<B>(fn(value));

// Term
// ====

Term: Type
  term_value<P: Term -> Type> ->
  (var:
    (hash: U32) ->
    (indx: Nat) ->
    P(var(indx))) ->
  (ref:
    (hash: U32) ->
    (name: String) ->
    P(ref(name))) ->
  (typ:
    (hash: U32) ->
    P(typ)) ->
  (all:
    (hash: U32) ->
    (eras: Bool) ->
    (self: String) ->
    (name: String) ->
    (bind: Term) ->
    (body: Term) ->
    P(all(eras)(self)(name)(bind)(body))) ->
  (lam:
    (hash: U32) ->
    (eras: Bool) ->
    (name: String) ->
    (body: Term) ->
    P(lam(eras)(name)(body))) ->
  (app:
    (hash: U32) ->
    (eras: Bool) ->
    (func: Term) ->
    (argm: Term) ->
    P(app(eras)(func)(argm))) ->
  (lit:
    (hash: U32) ->
    (name: String) ->
    (expr: Term) ->
    (body: Term) ->
    P(lit(name)(expr)(body))) ->
  (ann:
    (hash: U32) ->
    (done: Bool) ->
    (expr: Term) ->
    (type: Term) ->
    P(ann(done)(expr)(type))) ->
  P(term_value)

var: Nat -> Term
  (indx)
  <> (var) () () () () () () ()
  var(u32_0)(indx)

ref: String -> Term
  (name)
  <> () (ref) () () () () () ()
  ref(u32_0)(name)

typ: Term
  <> () () (typ) () () () () ()
  typ(u32_0)

all: Bool -> String -> String -> Term -> Term -> Term
  (eras) (self) (name) (bind) (body)
  <> () () () (all) () () () ()
  all(u32_0)(eras)(self)(name)(bind)(body)

lam: Bool -> String -> Term -> Term
  (eras) (name) (body)
  <> () () () () (lam) () () ()
  lam(u32_0)(eras)(name)(body)

app: Bool -> Term -> Term -> Term
  (eras) (func) (argm)
  <> () () () () () (app) () ()
  app(u32_0)(eras)(func)(argm)

lit: String -> Term -> Term -> Term
  (name) (expr) (body)
  <> () () () () () () (lit) ()
  lit(u32_0)(name)(expr)(body)

ann: Bool -> Term -> Term -> Term
  (done) (expr) (type)
  <> () () () () () () () (ann)
  ann(u32_0)(done)(expr)(type)

// Definitions
// ===========

Def: Type
  Pair(Term)(Term)

File: Type
  Map(Def)

get_def: File -> String -> Maybe(Def)
  (file) (name)
  lookup<Def>(string_to_bits(name))(file)

get_type: File -> String -> Maybe(Term)
  (file) (name)
  map_maybe<Def><Term>(fst<Term><Term>)(get_def(file)(name))

get_term: File -> String -> Maybe(Term)
  (file) (name)
  map_maybe<Def><Term>(snd<Term><Term>)(get_def(file)(name))

// Parsing
// =======

Parsed: (A: Type) -> Type
  (A) Maybe(Pair(String)(A))

parsed: <A: Type> -> String -> A -> Parsed(A)
  <A> (code) (val)
  some<Pair(String)(A)>(pair<String><A>(code)(val))

noparse: <A: Type> -> Parsed(A)
  <A> none<Pair(String)(A)>

parsing
  : <A: Type> ->
    <B: Type> ->
    (x: Parsed(A)) ->
    (f: String -> A -> Parsed(B)) ->
    Parsed(B)
  <A> <B> (x) (f)
  x<() Parsed(B)>
  | noparse<B>;
  | (value) value<() Parsed(B)>(f);

is_space: Char -> Bool
  (c)
    let is_spc = u32_eql(c)(_space)
    let is_tab = u32_eql(c)(_HT)
    let is_lin = u32_eql(c)(_LF)
    bool_or(is_spc)(bool_or(is_tab)(is_lin))

is_name: Char -> Bool
  (c)
    let is_num = bool_and(u32_gte(c)(_0))(u32_lte(c)(_9))
    let is_low = bool_and(u32_gte(c)(_a))(u32_lte(c)(_z))
    let is_upp = bool_and(u32_gte(c)(_A))(u32_lte(c)(_Z))
    let is_und = u32_eql(c)(_lowbar)
    bool_or(is_num)(bool_or(is_low)(bool_or(is_upp)(is_und)))

first_valid: <A: Type> -> List(Maybe(A)) -> Maybe(A)
  <A> (list)
  list<() Maybe(A)>
  | none<A>;
  | (head) (tail)
    head<() Maybe(A)>
    | first_valid<A>(tail);
    | (value) some<A>(value);;

drop_while: (Char -> Bool) -> String -> String
  (cond) (code)
  code<() String>
  | string_nil;
  | (head) (tail)
    cond(head)<() String>
    | drop_while(cond)(tail);
    | string_cons(head)(tail);;

drop_spaces: String -> String
  drop_while(is_space)

// TODO: /* multi-line comment */
drop_comment: String -> String
  (code)
  let code = drop_spaces(code)
  // Removes "// ... \n"
  let code = 
    let fst2 = string_take(n2)(code)
    let sla2 = string_cons(_sol)(string_cons(_sol)(string_nil))
    string_eql(fst2)(sla2)<() String>
    | let code = string_drop(n2)(code)
      let code = drop_while((x) bool_not(u32_eql(_LF)(x)))(code)
      code;
    | code;
  code

// TODO: remove comments
next: String -> String
  (code) drop_spaces(code)

parse_str: String -> String -> Parsed(String)
  (code) (str)
  str<() Parsed(String)>
  | parsed<String>(code)(str);
  | (str_head) (str_tail)
    code<() Parsed(String)>
    | noparse<String>;
    | (code_head) (code_tail)
      u32_eql(code_head)(str_head)<() Parsed(String)>
      | parse_str(code_tail)(str_tail);
      | noparse<String>;;;

parse_opt: String -> Pair(String)(String) -> Parsed(Bool)
  (code) (opts)
  opts<() Parsed(Bool)>
  | (ch0) (ch1)
    parse_str(code)(ch1)<() Parsed(Bool)>
    | parse_str(code)(ch0)<() Parsed(Bool)>
      | noparse<Bool>;
      | (got) got<() Parsed(Bool)>((code) (skip) parsed<Bool>(code)(true));;
    | (got) got<() Parsed(Bool)>((code) (skip) parsed<Bool>(code)(false));;

parse_nam_aux: String -> Pair(String)(String)
  (code)
  let ret = pair<String><String>
  code<() Pair(String)(String)>
  | ret(code)(string_nil);
  | (head) (tail)
    is_name(head)<() Pair(String)(String)>
    | parse_nam_aux(tail)<() Pair(String)(String)>
      | (code) (rest) ret(code)(string_cons(head)(rest));;
    | ret(code)(string_nil);;

parse_nam: String -> Bool -> Maybe(Pair(String)(String))
  (code) (allow_empty)
  parse_nam_aux(code)<() Parsed(String)>
  | (code) (name)
    bool_or(allow_empty)(bool_not(string_is_empty(name)))<() Parsed(String)>
    | parsed<String>(code)(name);
    | noparse<String>;;

// Stringification
// ===============

nest: Bool -> String -> String
  (b) (s)
  b<() String>
  | string_concat(LT)(string_concat(s)(GT));
  | string_concat(LPAR)(string_concat(s)(RPAR));

sp: String -> String
  (s) string_flatten(cons<String>(SPAC)(cons<String>(s)(single<String>(SPAC))))

ERR: String
  string_cons(_hash)(string_cons(_E)(string_cons(_R)(string_cons(_R)(string_nil))))

stringify_trm : List(String) -> Term -> String
  (vars) (term)
  let go = stringify_trm
  let cons    = cons<String>
  let space   = string_cons(_space)(string_nil)
  let single  = single<String>
  term<() String>
  |{-var-} () (indx) 
    let res = find<String>(vars)(() (i) nat_eql(indx)(i))
    res<() String>(ERR)((x) fst<String><Nat>(x));
  |{-ref-} () (nam) nam;
  |{-typ-} () TYPS;
  |{-all-} () (e) (s) (n) (h) (b)
    let body = go(cons(n)(cons(s)(vars)))(b)
    let head = nest(e)(string_flatten(cons(n)(cons(sp(COLO))(single(go(cons(s)(vars))(h))))))
    string_flatten(cons(s)(cons(head)(cons(sp(ARR0))(single(body)))));
  |{-lam-} () (e) (n) (b)
    let head = nest(e)(n)
    let body = go(cons(n)(vars))(b)
    string_flatten(cons(head)(cons(space)(single(body))));
  |{-app-} () (e) (f) (a)
    let fref = go(vars)(f)
    let fpar = nest(false)(fref)
    let func =
      f<() String>
      |{-var-} () () fref;
      |{-ref-} () () fref;
      |{-typ-} () fpar;
      |{-all-} () () () () () () fref;
      |{-lam-} () () () () fpar;
      |{-app-} () () () () fpar;
      |{-lit-} () () () () fpar;
      |{-ann-} () () () () fpar;
    let argm = nest(e)(go(vars)(a))
    string_flatten(cons(func)(single(argm)));
  |{-lit-} () (n) (x) (b)
    string_flatten(cons(LETS)(cons(n)(cons(sp(EQLS))(single(go(cons(n)(vars))(b))))));
  |{-ann-} () () (x) (t)
    string_flatten(cons(go(vars)(x))(cons(sp(COLS))(single(go(vars)(t)))));

stringify_term : Term -> String
  (t) stringify_trm(nil<String>)(t)

// Parsing
// =======

parse_par: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(LPAR)) | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (term)
  parsing<String><Term>(parse_str(next(code))(RPAR)) | (code) (skip)
  parsed<Term>(code)(term);;;

parse_com: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(DASH))  | (code) (skip)
  parsing<String><Term>(parse_nam(     code )(false)) | (code) (name)
  parsing<String><Term>(parse_str(next(code))(DASH))  | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars))  | (code) (term)
  parsed<Term>(code)(term);;;;

parse_all: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_nam(next(code))(true)) | (code) (self)
  parsing<Bool  ><Term>(parse_opt(     code )(OPEN)) | (code) (eras)
  parsing<String><Term>(parse_nam(next(code))(true)) | (code) (name)
  parsing<String><Term>(parse_str(next(code))(COLO)) | (code) (skip)
  let vars = cons<String>(self)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (bind)
  parsing<Bool  ><Term>(parse_opt(next(code))(CLOS)) | (code) (skip)
  parsing<String><Term>(parse_str(next(code))(ARR0)) | (code) (skip)
  let vars = cons<String>(name)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (body)
  parsed<Term>(code)(all(eras)(self)(name)(bind)(body));;;;;;;;

parse_lam: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<Bool  ><Term>(parse_opt(next(code))(OPEN)) | (code) (eras)
  parsing<String><Term>(parse_nam(next(code))(true)) | (code) (name)
  parsing<Bool  ><Term>(parse_opt(next(code))(CLOS)) | (code) (skip)
  let vars = cons<String>(name)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (body)
  parsed<Term>(code)(lam(eras)(name)(body));;;;

parse_let: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(LETS))  | (code) (skip)
  parsing<String><Term>(parse_nam(next(code))(false)) | (code) (name)
  parsing<String><Term>(parse_str(next(code))(EQLS))  | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars))  | (code) (expr)
  let vars = cons<String>(name)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars))  | (code) (body)
  parsed<Term>(code)(lit(name)(expr)(body));;;;;

parse_typ: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(TYPS)) | (code) (skip)
  parsed<Term>(code)(typ);

parse_var: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_nam(next(code))(false)) | (code) (name)
  find<String>(vars)((x) (i) string_eql(x)(name))<() Parsed(Term)>
  | parsed<Term>(code)(ref(name));
  | (value) parsed<Term>(code)(var(snd<String><Nat>(value)));;

parse_app: String -> Term -> List(String) -> Parsed(Term)
  (code) (func) (vars)
  parsing<Bool><Term>(parse_opt(      code )(OPEN)) | (code) (eras)
  parsing<Term><Term>(parse_trm(next(code))(vars)) | (code) (argm)
  parsing<Bool><Term>(parse_opt( next(code))(CLOS)) | (code) (skip)
  parsed<Term>(code)(app(eras)(func)(argm));;;

parse_pip: String -> Term -> List(String) -> Parsed(Term)
  (code) (func) (vars)
  parsing<String><Term>(parse_str(next(code))(PIPE)) | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (argm)
  parsing<String><Term>(parse_str(next(code))(SEMI)) | (code) (skip)
  parsed<Term>(code)(app(false)(func)(argm));;;

parse_arr: String -> Term -> List(String) -> Parsed(Term)
  (code) (bind) (vars)
  parsing<String><Term>(parse_str(next(code))(ARR0)) | (code) (skip)
  let vars = cons<String>(string_nil)(cons<String>(string_nil)(vars))
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (body)
  let term = all(false)(string_nil)(string_nil)(shift(bind)(n1)(n0))(body)
  parsed<Term>(code)(term);;

parse_ann: String -> Term -> List(String) -> Parsed(Term)
  (code) (expr) (vars)
  parsing<String><Term>(parse_str(next(code))(COLS)) | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (type)
  parsed<Term>(code)(ann(false)(expr)(type));;

parse_pst: String -> Term -> List(String) -> Parsed(Term)
  (code) (term) (vars)
  let post_parse = first_valid<Pair(String)(Term)>(
    cons<Parsed(Term)>(parse_app(code)(term)(vars))(
    cons<Parsed(Term)>(parse_pip(code)(term)(vars))(
    cons<Parsed(Term)>(parse_arr(code)(term)(vars))(
    cons<Parsed(Term)>(parse_ann(code)(term)(vars))(
    nil<Parsed(Term)>)))))
  post_parse<() Parsed(Term)>
  | parsed<Term>(code)(term);
  | (value)
    value<() Parsed(Term)>
    | (code) (term) parse_pst(code)(term)(vars);;

parse_trm: String -> List(String) -> Parsed(Term)
  (code) (vars)
  let base_parse = first_valid<Pair(String)(Term)>(
    cons<Parsed(Term)>(parse_all(code)(vars))(
    cons<Parsed(Term)>(parse_lam(code)(vars))(
    cons<Parsed(Term)>(parse_let(code)(vars))(
    cons<Parsed(Term)>(parse_par(code)(vars))(
    cons<Parsed(Term)>(parse_com(code)(vars))(
    cons<Parsed(Term)>(parse_typ(code)(vars))(
    cons<Parsed(Term)>(parse_var(code)(vars))(
    nil<Parsed(Term)>))))))))
  parsing<Term><Term>(base_parse)((code) (term)
    parse_pst(code)(term)(vars))

parse_file_aux: String -> File -> Parsed(File)
  (code) (file)
  let vars = nil<String>
  let next = 
    parsing<String><File>(parse_nam(next(code))(false)) | (code) (name)
    parsing<String><File>(parse_str(next(code))(COLO))  | (code) (skip)
    parsing<Term  ><File>(parse_trm(next(code))(vars))  | (code) (type)
    parsing<Term  ><File>(parse_trm(next(code))(vars))  | (code) (term)
    let defn = pair<Term><Term>(type)(term)
    let file = insert<Def>(string_to_bits(name))(defn)(file)
    //let file = insert<Def>(string_to_bits(name))(pair<Term><Term>(typ)(typ))(file)
    parsed<File>(code)(file);;;;
  next<() Parsed(File)>
  | parsed<File>(code)(file);
  | (p) p<() Parsed(File)> | (code) (file) parse_file_aux(code)(file);;
 
parse_term: String -> Parsed(Term)
  (code) parse_trm(code)(nil<String>)

parse_file: String -> Parsed(File)
  (code) parse_file_aux(code)(empty<Def>)

// Substitution
// ============

shift: Term -> Nat -> Nat -> Term
  (term) (inc) (dep)
  term<() Term>
  | (hash) (indx)
    nat_ltn(indx)(dep)<() Term>
    | var(indx);
    | var(nat_add(inc)(indx));;
  | (hash) (name)
    ref(name);
  | (hash)
    typ;
  | (hash) (eras) (self) (name) (bind) (body)
    let eras = eras
    let self = self
    let name = name
    let bind = shift(bind)(inc)(succ(dep))
    let body = shift(body)(inc)(succ(succ(dep)))
    all(eras)(self)(name)(bind)(body);
  | (hash) (eras) (name) (body)
    let eras = eras
    let name = name
    let body = shift(body)(inc)(succ(dep))
    lam(eras)(name)(body);
  | (hash) (eras) (func) (argm)
    let eras = eras
    let func = shift(func)(inc)(dep)
    let argm = shift(argm)(inc)(dep)
    app(eras)(func)(argm);
  | (hash) (name) (expr) (body)
    let name = name
    let expr = shift(expr)(inc)(dep)
    let body = shift(expr)(inc)(succ(dep))
    lit(name)(expr)(body);
  | (hash) (done) (expr) (type)
    let done = done
    let expr = shift(expr)(inc)(dep)
    let type = shift(expr)(inc)(dep)
    ann(done)(expr)(type);

subst: Term -> Term -> Nat -> Term
  (term) (val) (dep)
  term<() Term>
  | (hash) (indx)
    nat_cmp(indx)(dep)<() Term>
    | var(indx);
    | val;
    | var(pred(indx));;
  | (hash) (name)
    ref(name);
  | (hash)
    typ;
  | (hash) (eras) (self) (name) (bind) (body)
    let eras = eras
    let self = self
    let name = name
    let bind = subst(bind)(shift(val)(n1)(n0))(succ(dep))
    let body = subst(body)(shift(val)(n2)(n0))(succ(succ(dep)))
    all(eras)(self)(name)(bind)(body);
  | (hash) (eras) (name) (body)
    let eras = eras
    let name = name
    let body = subst(body)(shift(val)(n1)(n0))(succ(dep))
    lam(eras)(name)(body);
  | (hash) (eras) (func) (argm)
    let eras = eras
    let func = subst(func)(val)(dep)
    let argm = subst(argm)(val)(dep)
    app(eras)(func)(argm);
  | (hash) (name) (expr) (body)
    let name = name
    let expr = subst(expr)(val)(dep)
    let body = subst(expr)(shift(val)(n1)(n0))(succ(dep))
    lit(name)(expr)(body);
  | (hash) (done) (expr) (type)
    let done = done
    let expr = subst(expr)(val)(dep)
    let type = subst(expr)(val)(dep)
    ann(done)(expr)(type);

// Evaluation
// ==========

HTerm: Type
  hterm_value<P: HTerm -> Type> ->
  (hvar:
    (indx: Nat) ->
    (posi: Bool) ->
    P(hvar(indx)(posi))) ->
  (href:
    (name: String) ->
    P(href(name))) ->
  (htyp:
    P(htyp)) ->
  (hall:
    (eras: Bool) ->
    (bind: HTerm -> HTerm) ->
    (body: HTerm -> HTerm -> HTerm) ->
    P(hall(eras)(bind)(body))) ->
  (hlam:
    (body: HTerm -> HTerm) ->
    P(hlam(body))) ->
  (happ:
    (func: HTerm) ->
    (argm: HTerm) ->
    P(happ(func)(argm))) ->
  P(hterm_value)

hvar: Nat -> Bool -> HTerm
  (indx) (posi)
  <> (hvar) () () () () ()
  hvar(indx)(posi)

href: String -> HTerm
  (name)
  <> () (href) () () () ()
  href(name)

htyp: HTerm
  <> () () (htyp) () () ()
  htyp

hall: Bool -> (HTerm -> HTerm) -> (HTerm -> HTerm -> HTerm) -> HTerm
  (eras) (bind) (body)
  <> () () () (hall) () ()
  hall(eras)(bind)(body)

hlam: (HTerm -> HTerm) -> HTerm
  (body)
  <> () () () () (hlam) ()
  hlam(body)

happ: HTerm -> HTerm -> HTerm
  (func) (argm)
  <> () () () () () (happ)
  happ(func)(argm)

to_high_order: Term -> List(HTerm) -> Nat -> HTerm
  (term) (vars) (depth)
  term<() HTerm>
  | (hash) (indx)
    find<HTerm>(vars)((x) (i) nat_eql(i)(indx))<() HTerm>
    | hvar(nat_sub(succ(indx))(depth))(false);
    | (value) fst<HTerm><Nat>(value);;
  | (hash) (name)
    href(name);
  | (hash)
    htyp;
  | (hash) (eras) (self) (name) (bind) (body)
    hall
    | eras;
    | (s) to_high_order(bind)(cons<HTerm>(s)(vars))(succ(depth));
    | (s) (x) to_high_order(body)(cons<HTerm>(x)(cons<HTerm>(s)(vars)))(succ(succ(depth)));;
  | (hash) (eras) (name) (body)
    eras<() HTerm>
    | to_high_order(subst(body)(ref(string_nil))(n0))(vars)(depth);
    | hlam((x) to_high_order(body)(cons<HTerm>(x)(vars))(succ(depth)));;
  | (hash) (eras) (func) (argm)
    eras<() HTerm>
    | to_high_order(func)(vars)(depth);
    | let func = to_high_order(func)(vars)(depth)
      let argm = to_high_order(argm)(vars)(depth)
      happ(func)(argm);;
  | (hash) (name) (expr) (body)
    let expr = to_high_order(expr)(vars)(depth)
    let body = ((x) to_high_order(body)(cons<HTerm>(x)(vars))(succ(depth))) :: HTerm -> HTerm
    body(expr);
  | (hash) (done) (expr) (type)
    to_high_order(expr)(vars)(depth);

to_low_order: HTerm -> Nat -> Term
  (hterm) (depth)
  hterm<() Term>
  | (indx) (posi)
    posi<() Term>
    | var(nat_sub(nat_sub(depth)(indx))(n1));
    | var(nat_sub(nat_add(depth)(indx))(n1));;
  | (name)
    ref(name);
  | typ;
  | (eras) (bind) (body)
    let eras = eras
    let self = nat_to_string(depth) // TODO
    let name = nat_to_string(succ(depth)) // TODO
    let bind = to_low_order(bind(hvar(depth)(true)))(succ(depth))
    let body = to_low_order(body(hvar(depth)(true))(hvar(succ(depth))(true)))(succ(succ(depth)))
    all(eras)(self)(name)(bind)(body);
  | (body)
    let eras = false
    let name = nat_to_string(depth) // TODO
    let body = to_low_order(body(hvar(depth)(true)))(succ(depth))
    lam(eras)(name)(body);
  | (func) (argm)
    let eras = false
    let func = to_low_order(func)(depth)
    let argm = to_low_order(argm)(depth)
    app(eras)(func)(argm);

reduce_high_order: HTerm -> File -> HTerm
  (term) (file)
  term<() HTerm>
  | (term.indx) (term.posi)
    hvar(term.indx)(term.posi);
  | (term.name)
    get_term(file)(term.name)<() HTerm>
    | href(term.name);
    | (ref_term)
      let ref_term = to_high_order(ref_term)(nil<HTerm>)(zero)
      reduce_high_order(ref_term)(file);;
  | htyp;
  | (term.eras) (term.bind) (term.body)
    hall(term.eras)(term.bind)(term.body);
  | (term.body)
    hlam(term.body);
  | (term.func) (term.argm)
    let func = reduce_high_order(term.func)(file)
    func<() HTerm>
    | (func.indx) (func.posi)
      happ(hvar(func.indx)(func.posi))(reduce_high_order(term.argm)(file));
    | (func.name)
      happ(href(func.name))(reduce_high_order(term.argm)(file));
    | htyp;
    | (func.eras) (func.bind) (func.body)
      happ(hall(func.eras)(func.bind)(func.body))(reduce_high_order(term.argm)(file));
    | (func.body)
      reduce_high_order(func.body(term.argm))(file);
    | (func.func) (func.argm)
      happ(happ(func.func)(func.argm))(reduce_high_order(term.argm)(file));;

normalize_high_order: HTerm -> File -> HTerm
  (term) (file)
  let norm = reduce_high_order(term)(file)
  norm<() HTerm>
  | (norm.indx) (norm.posi)
    hvar(norm.indx)(norm.posi);
  | (norm.name)
    href(norm.name);
  | htyp;
  | (norm.eras) (norm.bind) (norm.body)
    hall
    | norm.eras;
    | (s) normalize_high_order(norm.bind(s))(file);
    | (s) (x) normalize_high_order(norm.body(s)(x))(file);;
  | (norm.body)
    hlam((x) normalize_high_order(norm.body(x))(file));
  | (norm.func) (norm.argm)
    let func = normalize_high_order(norm.func)(file)
    let argm = normalize_high_order(norm.argm)(file)
    happ(func)(argm);

reduce: Term -> File -> Term
  (term) (file)
  let hterm = to_high_order(term)(nil<HTerm>)(zero)
  let hterm = reduce_high_order(hterm)(file)
  to_low_order(hterm)(zero)

normalize: Term -> File -> Term
  (term) (file)
  let hterm = to_high_order(term)(nil<HTerm>)(zero)
  let hterm = normalize_high_order(hterm)(file)
  to_low_order(hterm)(zero)
  
// Constants
// =========

// \NUL
_NUL: Char
  ascii(o)(o)(o)(o)(o)(o)(o)(o)

// \SOH
_SOH: Char
  ascii(o)(o)(o)(o)(o)(o)(o)(i)

// \STX
_STX: Char
  ascii(o)(o)(o)(o)(o)(o)(i)(o)

// \ETX
_ETX: Char
  ascii(o)(o)(o)(o)(o)(o)(i)(i)

// \EOT
_EOT: Char
  ascii(o)(o)(o)(o)(o)(i)(o)(o)

// \ENQ
_ENQ: Char
  ascii(o)(o)(o)(o)(o)(i)(o)(i)

// \ACK
_ACK: Char
  ascii(o)(o)(o)(o)(o)(i)(i)(o)

// \BEL
_BEL: Char
  ascii(o)(o)(o)(o)(o)(i)(i)(i)

// \BS
_BS: Char
  ascii(o)(o)(o)(o)(i)(o)(o)(o)

// \HT
_HT: Char
  ascii(o)(o)(o)(o)(i)(o)(o)(i)

// \LF
_LF: Char
  ascii(o)(o)(o)(o)(i)(o)(i)(o)

// \VT
_VT: Char
  ascii(o)(o)(o)(o)(i)(o)(i)(i)

// \FF
_FF: Char
  ascii(o)(o)(o)(o)(i)(i)(o)(o)

// \CR
_CR: Char
  ascii(o)(o)(o)(o)(i)(i)(o)(i)

// \SO
_SO: Char
  ascii(o)(o)(o)(o)(i)(i)(i)(o)

// \S 
_SI: Char
  ascii(o)(o)(o)(o)(i)(i)(i)(i)

// \DLE
_DLE: Char
  ascii(o)(o)(o)(i)(o)(o)(o)(o)

// \DC1
_DC1: Char
  ascii(o)(o)(o)(i)(o)(o)(o)(i)

// \DC2
_DC2: Char
  ascii(o)(o)(o)(i)(o)(o)(i)(o)

// \DC3
_DC3: Char
  ascii(o)(o)(o)(i)(o)(o)(i)(i)

// \DC4
_DC4: Char
  ascii(o)(o)(o)(i)(o)(i)(o)(o)

// \NAK
_NAK: Char
  ascii(o)(o)(o)(i)(o)(i)(o)(i)

// \SYN
_SYN: Char
  ascii(o)(o)(o)(i)(o)(i)(i)(o)

// \ETB
_ETB: Char
  ascii(o)(o)(o)(i)(o)(i)(i)(i)

// \CAN
_CAN: Char
  ascii(o)(o)(o)(i)(i)(o)(o)(o)

// \EM
_EM: Char
  ascii(o)(o)(o)(i)(i)(o)(o)(i)

// \SUB
_SUB: Char
  ascii(o)(o)(o)(i)(i)(o)(i)(o)

// \ESC
_ESC: Char
  ascii(o)(o)(o)(i)(i)(o)(i)(i)

// \FS
_FS: Char
  ascii(o)(o)(o)(i)(i)(i)(o)(o)

// \GS
_GS: Char
  ascii(o)(o)(o)(i)(i)(i)(o)(i)

// \RS
_RS: Char
  ascii(o)(o)(o)(i)(i)(i)(i)(o)

// \US
_US: Char
  ascii(o)(o)(o)(i)(i)(i)(i)(i)

// ' '
_space: Char
  ascii(o)(o)(i)(o)(o)(o)(o)(o)

// '!'
_excl: Char
  ascii(o)(o)(i)(o)(o)(o)(o)(i)

// '"'
_quot: Char
  ascii(o)(o)(i)(o)(o)(o)(i)(o)

// '#'
_hash: Char
  ascii(o)(o)(i)(o)(o)(o)(i)(i)

// '$'
_dollar: Char
  ascii(o)(o)(i)(o)(o)(i)(o)(o)

// '%'
_percnt: Char
  ascii(o)(o)(i)(o)(o)(i)(o)(i)

// '&'
_amp: Char
  ascii(o)(o)(i)(o)(o)(i)(i)(o)

// '\''
_apos: Char
  ascii(o)(o)(i)(o)(o)(i)(i)(i)

// '('
_lpar: Char
  ascii(o)(o)(i)(o)(i)(o)(o)(o)

// ')'
_rpar: Char
  ascii(o)(o)(i)(o)(i)(o)(o)(i)

// '*'
_ast: Char
  ascii(o)(o)(i)(o)(i)(o)(i)(o)

// '+'
_plus: Char
  ascii(o)(o)(i)(o)(i)(o)(i)(i)

// ','
_comma: Char
  ascii(o)(o)(i)(o)(i)(i)(o)(o)

// '-'
_dash: Char
  ascii(o)(o)(i)(o)(i)(i)(o)(i)

// '.'
_period: Char
  ascii(o)(o)(i)(o)(i)(i)(i)(o)

// '/'
_sol: Char
  ascii(o)(o)(i)(o)(i)(i)(i)(i)

// '0'
_0: Char
  ascii(o)(o)(i)(i)(o)(o)(o)(o)

// '1'
_1: Char
  ascii(o)(o)(i)(i)(o)(o)(o)(i)

// '2'
_2: Char
  ascii(o)(o)(i)(i)(o)(o)(i)(o)

// '3'
_3: Char
  ascii(o)(o)(i)(i)(o)(o)(i)(i)

// '4'
_4: Char
  ascii(o)(o)(i)(i)(o)(i)(o)(o)

// '5'
_5: Char
  ascii(o)(o)(i)(i)(o)(i)(o)(i)

// '6'
_6: Char
  ascii(o)(o)(i)(i)(o)(i)(i)(o)

// '7'
_7: Char
  ascii(o)(o)(i)(i)(o)(i)(i)(i)

// '8'
_8: Char
  ascii(o)(o)(i)(i)(i)(o)(o)(o)

// '9'
_9: Char
  ascii(o)(o)(i)(i)(i)(o)(o)(i)

// ':'
_colon: Char
  ascii(o)(o)(i)(i)(i)(o)(i)(o)

// ';'
_semi: Char
  ascii(o)(o)(i)(i)(i)(o)(i)(i)

// '<'
_lt: Char
  ascii(o)(o)(i)(i)(i)(i)(o)(o)

// '='
_equals: Char
  ascii(o)(o)(i)(i)(i)(i)(o)(i)

// '>'
_gt: Char
  ascii(o)(o)(i)(i)(i)(i)(i)(o)

// '?'
_quest: Char
  ascii(o)(o)(i)(i)(i)(i)(i)(i)

// '@'
_commat: Char
  ascii(o)(i)(o)(o)(o)(o)(o)(o)

// 'A'
_A: Char
  ascii(o)(i)(o)(o)(o)(o)(o)(i)

// 'B'
_B: Char
  ascii(o)(i)(o)(o)(o)(o)(i)(o)

// 'C'
_C: Char
  ascii(o)(i)(o)(o)(o)(o)(i)(i)

// 'D'
_D: Char
  ascii(o)(i)(o)(o)(o)(i)(o)(o)

// 'E'
_E: Char
  ascii(o)(i)(o)(o)(o)(i)(o)(i)

// 'F'
_F: Char
  ascii(o)(i)(o)(o)(o)(i)(i)(o)

// 'G'
_G: Char
  ascii(o)(i)(o)(o)(o)(i)(i)(i)

// 'H'
_H: Char
  ascii(o)(i)(o)(o)(i)(o)(o)(o)

// 'I'
_I: Char
  ascii(o)(i)(o)(o)(i)(o)(o)(i)

// 'J'
_J: Char
  ascii(o)(i)(o)(o)(i)(o)(i)(o)

// 'K'
_K: Char
  ascii(o)(i)(o)(o)(i)(o)(i)(i)

// 'L'
_L: Char
  ascii(o)(i)(o)(o)(i)(i)(o)(o)

// 'M'
_M: Char
  ascii(o)(i)(o)(o)(i)(i)(o)(i)

// 'N'
_N: Char
  ascii(o)(i)(o)(o)(i)(i)(i)(o)

// 'O'
_O: Char
  ascii(o)(i)(o)(o)(i)(i)(i)(i)

// 'P'
_P: Char
  ascii(o)(i)(o)(i)(o)(o)(o)(o)

// 'Q'
_Q: Char
  ascii(o)(i)(o)(i)(o)(o)(o)(i)

// 'R'
_R: Char
  ascii(o)(i)(o)(i)(o)(o)(i)(o)

// 'S'
_S: Char
  ascii(o)(i)(o)(i)(o)(o)(i)(i)

// 'T'
_T: Char
  ascii(o)(i)(o)(i)(o)(i)(o)(o)

// 'U'
_U: Char
  ascii(o)(i)(o)(i)(o)(i)(o)(i)

// 'V'
_V: Char
  ascii(o)(i)(o)(i)(o)(i)(i)(o)

// 'W'
_W: Char
  ascii(o)(i)(o)(i)(o)(i)(i)(i)

// 'X'
_X: Char
  ascii(o)(i)(o)(i)(i)(o)(o)(o)

// 'Y'
_Y: Char
  ascii(o)(i)(o)(i)(i)(o)(o)(i)

// 'Z'
_Z: Char
  ascii(o)(i)(o)(i)(i)(o)(i)(o)

// '['
_lbrack: Char
  ascii(o)(i)(o)(i)(i)(o)(i)(i)

// '\\'
_bsol: Char
  ascii(o)(i)(o)(i)(i)(i)(o)(o)

// ']'
_rbrack: Char
  ascii(o)(i)(o)(i)(i)(i)(o)(i)

// '^'
_caret: Char
  ascii(o)(i)(o)(i)(i)(i)(i)(o)

// '_'
_lowbar: Char 
  ascii(o)(i)(o)(i)(i)(i)(i)(i)

// '`'
_grave: Char
  ascii(o)(i)(i)(o)(o)(o)(o)(o)

// 'a'
_a: Char
  ascii(o)(i)(i)(o)(o)(o)(o)(i)

// 'b'
_b: Char
  ascii(o)(i)(i)(o)(o)(o)(i)(o)

// 'c'
_c: Char
  ascii(o)(i)(i)(o)(o)(o)(i)(i)

// 'd'
_d: Char
  ascii(o)(i)(i)(o)(o)(i)(o)(o)

// 'e'
_e: Char
  ascii(o)(i)(i)(o)(o)(i)(o)(i)

// 'f'
_f: Char
  ascii(o)(i)(i)(o)(o)(i)(i)(o)

// 'g'
_g: Char
  ascii(o)(i)(i)(o)(o)(i)(i)(i)

// 'h'
_h: Char
  ascii(o)(i)(i)(o)(i)(o)(o)(o)

// 'i'
_i: Char
  ascii(o)(i)(i)(o)(i)(o)(o)(i)

// 'j'
_j: Char
  ascii(o)(i)(i)(o)(i)(o)(i)(o)

// 'k'
_k: Char
  ascii(o)(i)(i)(o)(i)(o)(i)(i)

// 'l'
_l: Char
  ascii(o)(i)(i)(o)(i)(i)(o)(o)

// 'm'
_m: Char
  ascii(o)(i)(i)(o)(i)(i)(o)(i)

// 'n'
_n: Char
  ascii(o)(i)(i)(o)(i)(i)(i)(o)

// 'o'
_o: Char
  ascii(o)(i)(i)(o)(i)(i)(i)(i)

// 'p'
_p: Char
  ascii(o)(i)(i)(i)(o)(o)(o)(o)

// 'q'
_q: Char
  ascii(o)(i)(i)(i)(o)(o)(o)(i)

// 'r'
_r: Char
  ascii(o)(i)(i)(i)(o)(o)(i)(o)

// 's'
_s: Char
  ascii(o)(i)(i)(i)(o)(o)(i)(i)

// 't'
_t: Char
  ascii(o)(i)(i)(i)(o)(i)(o)(o)

// 'u'
_u: Char
  ascii(o)(i)(i)(i)(o)(i)(o)(i)

// 'v'
_v: Char
  ascii(o)(i)(i)(i)(o)(i)(i)(o)

// 'w'
_w: Char
  ascii(o)(i)(i)(i)(o)(i)(i)(i)

// 'x'
_x: Char
  ascii(o)(i)(i)(i)(i)(o)(o)(o)

// 'y'
_y: Char
  ascii(o)(i)(i)(i)(i)(o)(o)(i)

// 'z'
_z: Char
  ascii(o)(i)(i)(i)(i)(o)(i)(o)

// '{'
_lbrace: Char
  ascii(o)(i)(i)(i)(i)(o)(i)(i)

// '|'
_vert: Char
  ascii(o)(i)(i)(i)(i)(i)(o)(o)

// '}'
_rbrace: Char
  ascii(o)(i)(i)(i)(i)(i)(o)(i)

// '~'
_tilde: Char
  ascii(o)(i)(i)(i)(i)(i)(i)(o)

// \DEL
_DEL: Char
  ascii(o)(i)(i)(i)(i)(i)(i)(i)

// "("
LPAR: String
  string_cons(_lpar)(string_nil)

// ")"
RPAR: String
  string_cons(_rpar)(string_nil)

// "{"
LSIG: String
  string_cons(_lbrace)(string_nil)

// "}"
RSIG: String
  string_cons(_rbrace)(string_nil)

// "<"
LT: String
  string_cons(_lt)(string_nil)

// ">"
GT: String
  string_cons(_gt)(string_nil)

// ":"
COLO: String
  string_cons(_colon)(string_nil)

// ":"
SEMI: String
  string_cons(_semi)(string_nil)

// "-"
DASH: String
  string_cons(_dash)(string_nil)

// "|"
PIPE: String
 string_cons(_vert)(string_nil)

// "::"
COLS: String
  string_cons(_colon)(string_cons(_colon)(string_nil))

// "->"
ARR0: String
  string_cons(_dash)(string_cons(_gt)(string_nil))

// "="
EQLS: String
  string_cons(_equals)(string_nil)

// Type
TYPS: String
  string_cons(_T)(string_cons(_y)(string_cons(_p)(string_cons(_e)(string_nil))))

// "let "
LETS: String
  string_cons(_l)(string_cons(_e)(string_cons(_t)(string_cons(_space)(string_nil))))

// "main"
MAIN: String
  string_cons(_m) |
  string_cons(_a) |
  string_cons(_i) |
  string_cons(_n) |
  string_nil;;;;

// "Hello, world!"
HELLO_WORLD: String
  string_cons(_H) |
  string_cons(_e) |
  string_cons(_l) |
  string_cons(_l) |
  string_cons(_o) |
  string_cons(_space) |
  string_cons(_w) |
  string_cons(_o) |
  string_cons(_r) |
  string_cons(_l) |
  string_cons(_d) |
  string_cons(_excl) |
  string_nil;;;;;;;;;;;;

// " "
SPAC: String
  string_cons(_space)(string_nil)

// ["(","{"]
OPEN: Pair(String)(String)
  pair<String><String>(LT)(LPAR)

// [")","}']
CLOS: Pair(String)(String)
  pair<String><String>(GT)(RPAR)

// Main
// ====

// A simple "Hello, world!"
example_0: String
  string_drop(n6)(HELLO_WORLD)

// Adding Uint32 values
example_1: U32
  let num = u32(
    w1<n31>(w0<n30>(w1<n29>(w1<n28>(w0<n27>(w0<n26>(w0<n25>(w0<n24>(
    w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
    w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
    w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
    we)))))))))))))))))))))))))))))))))
  u32_add(num)(num)

// Testing tail-call optimization to create a huge number
example_2: Nat
  let n100  = nat_mul(n10)(n10)
  let n1k   = nat_mul(n10)(n100)
  let n10k  = nat_mul(n10)(n1k)
  let n100k = nat_mul(n10)(n10k)
  let n1m   = nat_mul(n10)(n100k)
  let n10m  = nat_mul(n10)(n1m)
  nat_sum(n10m)

// Exports
// =======

Exports: Type
  <P: Type> ->
  (export: <A: Type> -> (x: A) -> (xs: P) -> P) ->
  (module: P) ->
  P

main: Exports
  <P> (export) (module)
  ( export<Term -> String               >(stringify_term)
  | export<File -> String -> Maybe(Term)>(get_term)
  | export<File -> String -> Maybe(Term)>(get_type)
  | export<Term -> File -> Term         >(normalize)
  | export<String -> Parsed(File)       >(parse_file)
  | export<String -> Parsed(Term)       >(parse_term)
  | module;;;;;;)
